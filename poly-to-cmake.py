"""
This module reads a Polyspace options file (that was generated by watching a build)
and generated CMakeLists.txt files for each directory in the target repository.
"""
import os
import re
import sys
from typing import Dict, List, Set, FrozenSet
from collections import defaultdict

DirectoryName = str
FileName = str


def usage():
    print(""" Usage:
    python factoroptions.py input-options-filename
    """)
    sys.exit(1)


def get_includes(line: str) -> Set[str]:
    """ Return the set of Include options from the -options-for-sources line. """
    parts = line.split(";")
    # parts[0] has the -options-for-sources and the source file.
    includes = {part for part in parts
                if (part.startswith("-I ") and not part.startswith("-I /usr"))}
    return includes

def partition_parts(part_dict: Dict[str, List[str]]) -> List[Set[str]]:
    part_keys = list(part_dict)
    num_keys = len(part_keys)
    assert(num_keys > 0)
    first_key = part_keys[0]
    first_list = part_dict[first_key]
    first_set = set(first_list)
    partition = [first_set]
    all_parts = set()
    for i in range(1, num_keys):
        for pi in partition:
            if len(pi) == 0:
                assert(False)
        parts = set(part_dict[part_keys[i]])
        all_parts.update(parts)
        new_partition = []
        for pi in partition:
            if len(parts) == 0:
                new_partition.append(pi)
            elif parts.isdisjoint(pi):
                    new_partition.append(pi)
            elif parts == pi:
                new_partition.append(pi)
                parts = set()
            else:
                inter = parts.intersection(pi)
                dif = pi.difference(parts)
                parts = parts.difference(pi)
                new_partition.append(inter)
                if len(dif) > 0:
                    new_partition.append(dif)
                pass
            pass
        if len(parts) > 0:
            new_partition.append(parts)
        partition = new_partition
        pass
    pass
    partition = sorted(partition, key=len, reverse=True)
    partition_all = set();
    for pi in partition:
        partition_all.update(pi)
    assert(all_parts == partition_all)
    for i in range(len(partition)):
        for k in range(i+1, len(partition)):
            assert(partition[i].isdisjoint(partition[k]))
    return partition

def get_file_partition_indices(part_dict: Dict[FileName, List[str]], partition) -> Dict[FileName, List[int]]:
    result = {}
    for file in part_dict:
        parts = part_dict[file]
        part_set = set(parts)
        file_result = []
        result[file] = file_result
        for i in range(len(partition)):
            parti = partition[i]
            if parti <= part_set:
                file_result.append(i)
        pass
    return result


def get_index_groups(file_indices: Dict[FileName, List[int]]) -> Dict[FrozenSet[int], List[FileName]]:
    """
    The range of file_indices is a list of indices into the partition of options/definitions, etc.
    Call these option partition groups.

    Results returned:

    group_list - a list of frozen groups, sorted by descending frequency of use.

    """

    #
    group_to_file_list_dict: Dict[FrozenSet[int], List[FileName]] = {}
    for file in list(file_indices):
        indices = frozenset(file_indices[file])
        if indices in group_to_file_list_dict:
            group_to_file_list_dict[indices].append(file)
        else:
            group_to_file_list_dict[indices] = [file]
    group_list = sorted(list(group_to_file_list_dict), key=lambda fset: len(group_to_file_list_dict[fset]), reverse=True);
    group_indices = dict([[group_list[i], i] for i in range(len(group_list))])
    group_index_to_files = dict([[group_indices[fset], group_to_file_list_dict[fset]] for fset in group_list])
    file_group = dict([[file, group_indices[frozenset(file_indices[file])]] for file in list(file_indices)])
    group_index_to_dirs = dict([[fset_index, set([os.path.dirname(file) for file in group_index_to_files[fset_index]])] for fset_index in group_index_to_files])
    # Get which group indices a directory is in. We fill in with empty lists so the
    # dictionary will be in alphabetical order (because the files are).
    dir_groups : Dict[DirectoryName, List[int]] = dict([[os.path.dirname(file), []] for file in list(file_indices)])

    for fset_index in list(group_index_to_dirs):
        dirs = group_index_to_dirs[fset_index]
        for dir in dirs:
            dir_groups[dir].append(fset_index)
    return (group_list, group_index_to_files, file_group, group_index_to_dirs, dir_groups)

def strip_leading(arg: str, leading: str):
    if arg.startswith(leading):
        return "./" + arg[len(leading):]
    else:
        return arg

class CmakeConfigure:
    """ Digest .depend files"""

    def adjust_src(self, arg: str):
        for old in list(self.adjust_dict):
            if arg.startswith(old):
                return self.adjust_dict[old] + arg[len(old):]
        return arg

    def strip_inc(self, arg: str):
        if arg.startswith('-I '):
            return '-I ' + self.adjust_src(arg[3:])
        else:
            return arg


    def __init__(self, input_filename: FileName, output_dir: DirectoryName, path_maps: List[DirectoryName]):
        self.input_filename = input_filename
        self.output_dir = output_dir
        self.adjusted_paths = [path + '/' if not path.endswith("/") else path for path in path_maps]
        # Target without trailing slash.
        self.adjusted_target_dir = self.adjusted_paths[1][:-1]
        self.adjust_dict = dict([[self.adjusted_paths[i], self.adjusted_paths[i+1]]
                                 for i in range(0, len(self.adjusted_paths), 2)])
        self.lines = self.read_input
        # Collect the -options-for-sources lines.
        self.ofs_lines = [line[len("-options-for-sources "):] for line in self.lines if line.startswith("-options-for-sources ")]
        ofs_dict0 = dict([[self.adjust_src(line.split(";")[0]), [self.strip_inc(option) for option in line.split(";")[1:]]]
                          for line in self.ofs_lines])
        # Get ofs_dict in sorted order.
        self.filenames = sorted(ofs_dict0.keys())
        self.ofs_dict = dict([[file, ofs_dict0[file]] for file in self.filenames])
        self.partition = partition_parts(self.ofs_dict)
        self.indices_dict = get_file_partition_indices(self.ofs_dict, self.partition)
        self.group_list, self.group_index_to_files, self.file_group, self.group_index_to_dirs, self.dir_groups = \
            get_index_groups(self.indices_dict)

        # common_includes = get_includes(self.ofs_lines[0])
        # common_usr_includes = get_usr_includes(self.ofs_lines[0])
        # common_other = get_non_includes(self.ofs_lines[0])
        # print(f"len(common_includes) = {len(common_includes)}")
        # print(f"len(common_usr_includes) = {len(common_usr_includes)}")
        # print(f"len(common_other) = {len(common_other)}")
        # includes_list = []
        # usr_includes_list = []
        # other_list = []
        # for i in range(1, len(self.ofs_lines)):
        #     this_includes = get_includes(self.ofs_lines[i])
        #     includes_list.append(this_includes)
        #     common_includes = common_includes.intersection(this_includes)
        #     print(f"len(common_includes) = {len(common_includes)}")
        #     this_usr_includes = get_usr_includes(self.ofs_lines[i])
        #     usr_includes_list.append(this_usr_includes)
        #     common_usr_includes = common_usr_includes.intersection(this_usr_includes)
        #     print(f"len(common_usr_includes) = {len(common_usr_includes)}")
        #     this_other = get_non_includes((self.ofs_lines[i]))
        #     other_list.append(this_other)
        #     common_other = common_other.intersection(this_other)
        #     print(f"len(common_other) = {len(common_other)}")
        #
        # self.common_includes = common_includes
        # self.common_usr_includes = common_usr_includes
        # self.common_other = common_other
        # self.factored = self.compute_output()
        pass

    @property
    def read_input(self) -> List[str]:
        with open(self.input_filename, 'r') as f:
            lines = [line.strip("\\\n") for line in f]
            return lines


    def output_simple_cmake_file_for_dir(self, dir: DirectoryName, w):
        w.write(f"Simple cmake for dir={dir}\n")
        return

    def output_cmake_file_for_dir(self, dir: DirectoryName):

        if not dir.startswith(self.adjusted_target_dir):
            # Skip directories not in the main tree.
            print(f"Skipping dir={dir}")
            return

        print(f"Processing dir={dir}")
        relative_dir = dir[len(self.adjusted_target_dir):]
        actual_target_dir = self.output_dir + relative_dir
        os.makedirs(actual_target_dir, exist_ok=True)
        cmake_file = os.path.join(actual_target_dir, "CMakeLists.txt")
        with open(cmake_file, "w") as w:
            if len(self.dir_groups[dir]) == 1:
                self.output_simple_cmake_file_for_dir(dir, w)
            else:
                w.write(f"Complex dir={dir}\n")

        print(f"Done processing dir={dir}")

        pass

    def find_children_dirs(self):
        children_dict: Dict[DirectoryName, Set[DirectoryName]] = {}
        for the_dir in list(self.dir_groups):
            parent = os.path.dirname(the_dir)
            child = the_dir
            while parent != '':
                if parent in children_dict:
                    parent_set = children_dict[parent]
                else:
                    parent_set = set()
                    children_dict[parent] = parent_set
                parent_set.add(child)
                child = parent
                parent = os.path.dirname(parent)
        self.children_dict = children_dict
        print("Finished find_children_dirs")
        pass

    def output_cmake_files(self):
        dirnames = list(self.dir_groups)
        for dir in dirnames :
            self.output_cmake_file_for_dir(dir)
        print(f"")
        pass

def usage():
    """ Usage:
    python3 poly-to-cmake.py poly_options_file target_dir [source_dir1 target_dir1 ...]

    Write CMakeLists.txt files for a project that has previously
    been configured for Polyspace.

    poly_options_file is the path to a Polyspace options file
    that contains the compilation options for each file of the project.

    target_dir is the root of a directory tree into which the
    cmake configuration files will be written. Usually this
    will be a directory with the source files, but for
    testing purposes it might be an empty directory.

    Additional (source_dir, target_dir) pairs may be given
    and paths starting with a source_dir will be rewritten to
    reference the corresponding target_dir. At least
    one pair must be given. source_dir1 is the root of the
    code being compiled and we only produce CMakeLists.txt files
    for directories under it. target_dir1 will be either
    an actual or symbolic (e.g. ${top}) name of the target
    directory into which the CMakeLists.txt files are written.
    So semantically target_dir and target_dir1 are the same.
    """
    print(usage.__doc__)
    sys.exit(1)

if __name__ == u'__main__':
    print('Using PolySpace Code Prover options to produce cmake configuration\n')
    options = sys.argv[1:]
    if len(options) < 4 or (len(options) % 2 != 0):
        usage()


    cmconfig = CmakeConfigure(options[0], options[1], options[2:])
    cmconfig.find_children_dirs()
    cmconfig.output_cmake_files()
    print('\ndone.\n')
